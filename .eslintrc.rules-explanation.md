# ESLint Custom Rules - Wyjaśnienie

## 🎯 Cel

ESLint został skonfigurowany tak, aby automatycznie sprawdzał i wymuszał konwencje projektu ustalone podczas audytu. Dzięki temu:
- ✅ Kod jest spójny w całym projekcie
- ✅ Błędy są wykrywane przed commitowaniem
- ✅ Nowi deweloperzy szybciej uczą się konwencji
- ✅ Redukcja code review czasu

## 📋 Konwencje projektu wymuszane przez ESLint

### 1. ✅ Użycie `cn()` zamiast template literals
**Reguła:** `no-restricted-syntax` dla template literals w className
**Poziom:** `error`

**Dlaczego:** Zapewnia spójność budowania klas CSS w całym projekcie.

**Przykład błędny:**
```javascript
className={`base-class ${condition ? 'active' : ''}`}
// ❌ ESLint Error: Używaj cn() zamiast template literals dla className
```

**Przykład poprawny:**
```javascript
className={cn('base-class', condition && 'active')}
// ✅ OK
```

### 2. ✅ Użycie `getIcon()` zamiast lokalnego `iconMap`
**Reguła:** `no-restricted-syntax` dla definicji `iconMap`

**Dlaczego:** Eliminuje duplikację i zapewnia centralne zarządzanie ikonami.

**Przykład błędny:**
```javascript
const iconMap = {
  FaCertificate,
  FaGraduationCap,
};
const Icon = iconMap[iconName];
```

**Przykład poprawny:**
```javascript
import { getIcon } from '@/lib/icons';
const Icon = getIcon(iconName);
```

### 3. ✅ Index exports dla komponentów
**Reguła:** `no-restricted-imports` dla bezpośrednich importów

**Dlaczego:** Zapewnia spójność importów i łatwiejsze refaktoryzacje.

**Przykład błędny:**
```javascript
import Button from '@/components/primitives/Button';
```

**Przykład poprawny:**
```javascript
import { Button } from '@/components/primitives';
```

### 4. ✅ Brak `!important` w Tailwind
**Reguła:** `no-restricted-syntax` dla `!important` w className

**Dlaczego:** Zapewnia czytelność i łatwiejsze utrzymanie. Użyj props zamiast tego.

**Przykład błędny:**
```javascript
className="!py-0 !px-0"
```

**Przykład poprawny:**
```javascript
<Section py={0} px={0}>
```

### 5. ✅ Wyjątki

- **prefers-reduced-motion:** `!important` jest dozwolone (uzasadnione użycie w CSS)
- **lib/icons.js:** Lokalny `iconMap` jest dozwolony (to jest definicja główna)
- **Pliki konfiguracyjne:** `.eslintrc.js`, `*.config.js` - wszystkie reguły wyłączone
- **Foldery:** `hooks`, `forms`, `layout`, `overlay`, `context`, `utils` - bezpośrednie importy są OK (brak index exports)

## 🔧 Jak to działa?

ESLint używa:
- **`no-restricted-syntax`** - sprawdza wzorce AST (Abstract Syntax Tree) używając selektorów
- **`no-restricted-imports`** - sprawdza ścieżki importów i ostrzega przed bezpośrednimi importami

**Poziomy:**
- `error` - dla template literals, iconMap, !important
- `warn` - dla importów (niektóre mogą być potrzebne)

## 🚫 Wyłączenie reguł (tylko w uzasadnionych przypadkach)

```javascript
// eslint-disable-next-line no-restricted-syntax
const specialCase = `template literal dla specjalnego przypadku`;
```

**Uwaga:** Unikaj wyłączania reguł jeśli to możliwe. Zastanów się czy nie można naprawić kodu.

## 📝 Aktualizacja reguł

Reguły są zdefiniowane w `.eslintrc.js` w sekcji:
- `no-restricted-syntax` (linie ~89-119)
- `no-restricted-imports` (linie ~120-138)

## 🧪 Testowanie reguł

```bash
# Sprawdź wszystkie pliki
npm run lint

# Sprawdź konkretny plik
npx eslint components/ui/CardWithIcon.js

# Auto-fix (dla niektórych reguł)
npm run lint:fix
```

## 💡 Przykłady błędów

Po dodaniu nowego kodu, ESLint automatycznie pokaże błędy:

```bash
✖ 1 problem (1 error, 0 warnings)

components/Test.js
  10:15  error  Używaj cn() zamiast template literals dla className  no-restricted-syntax
```

## 📚 Dokumentacja

Szczegóły każdej konwencji znajdziesz w `STYLE_GUIDE.md`.
